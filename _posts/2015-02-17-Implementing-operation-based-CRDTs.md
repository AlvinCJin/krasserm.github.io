---
title: Implementing operation-based CRDTs in Scala 
layout: post
comments: true
---

As already mentioned in a [previous post](http://krasserm.github.io/2015/01/13/event-sourcing-at-global-scale/), [eventuate](https://github.com/RBMHTechnology/eventuate) can be used to replicate actor state via event sourcing where replicas remain available for writes during network partitions. In the upcoming 0.1 release, eventuate will additionally provide implementations of [operation-based CRDTs](http://en.wikipedia.org/wiki/Conflict-free_replicated_data_type#Operation-based_CRDTs) (CmRDTs) as specified in the paper [A comprehensive study of Convergent and Commutative Replicated Data Types](http://hal.upmc.fr/docs/00/55/55/88/PDF/techreport.pdf) by Marc Shapiro et. al. Currently, the following CmRDTs are implemented (others coming soon):

- [Counter](#counter) (specification 5)
- [MV-Register](#mv-register) (op-based version of specification 10) 
- [OR-Set](#or-set) (specification 15)

Basis for the implementation are a replicated [event log](https://github.com/RBMHTechnology/eventuate/blob/master/README.md#event-log) and [event-sourced actors](https://github.com/RBMHTechnology/eventuate/blob/master/README.md#event-sourced-actors) with the following properties:

- The replicated event log is used for the reliable update-operation broadcast needed by CmRDTs.  
- The replicated event log is partition-tolerant i.e. applications can continue writing to a local replica during a network partition. 
- The replicated event log preserves causal relationship of events which satisfies all _downstream_ preconditions of the CmRDTs specified in the paper.
- The vector timestamps generated by event-sourced actors are used by some CmRDTs to determine whether any two updates are concurrent or causally related.
- CmRDT instances are maintained by event-sourced actors in-memory and can be recovered by replaying update operations (optionally starting from a snapshot). 

The specification of CmRDT updates has a close relationship to the command and event handler of an event-sourced actor. CmRDT updates have two phases:

- The first phase, _atSource_, can be implemented with a command handler (`onCommand`): It it takes arguments from the operation invocation, checks preconditions and is **not** allowed to make side effects. It may compute results, returned to the caller, and/or prepare arguments (= persist operation events) for the second phase.
- The second phase, _downstream_, can be implemented with an event handler (`onEvent`): It executes immediately at the local replica (= event sourced actor consumes the operation event it generated) and asynchronously at all other replicas (= other event sourced actors on the same replicated event log consume the operation event too). Consumed operation events finally change the state of CmRDTs that are managed by event-sourced actors. 

Usage
-----

### Counter

The default CmRDT implementations in eventuate don't expose event-sourced actors directly, instead, they provides service interfaces for applications to read and update CmRDTs. There's a service interface for each supported CmRDT type. For example, `Counter[A]` CmRDTs are managed by
`CounterService[A]` which provides the following read and update operations. 

    class CounterService[A : Integral](val processId: String, val log: ActorRef) {
      def value(id: String): Future[A] = { ... }
      def update(id: String, delta: A): Future[A] = { ... }
    }

The `value` method reads a counter value, `update` updates a counter value with a given `delta`. Counter instances are identified by application-defined `id`s. Each `CounterService` replica must have a unique `processId` and a reference to the replicated event `log`. The following example creates and uses a `CounterService[Int]` for reading and updating `Counter[Int]` CmRDTs.

    import akka.actor.ActorRef
    import com.rbmhtechnology.eventuate.crdt.CounterService

    val eventLog: ActorRef = ...
    val counterService = new CounterService[Int]("counter-replica-1", eventLog)

    // counter-1 usage
    counterService.update("counter-1", 11) // increment
    counterService.update("counter-1", -2) // decrement
    counterService.value("counter-1")      // read

    // counter-2 usage
    counterService.value("counter-2")     // read
    counterService.update("counter-2", 3) // increment

Counters are created on demand if referenced the first time by an update operation.

### MV-Register

`MVRegister[A]` CmRDTs are managed by `MVRegisterService[A]` which provides the following read and update operations.

    class MVRegisterService[A](val processId: String, val log: ActorRef) {
      def value(id: String): Future[Set[A]] = { ... }
      def set(id: String, value: A): Future[Set[A]] = { ... }
    }

### OR-Set

`ORSet[A]` CmRDTs are managed by `ORSetService[A]` which provides the following read and update operations.

    class ORSetService[A](val processId: String, val log: ActorRef) {
      def value(id: String): Future[Set[A]] = { ... }
      def add(id: String, entry: A): Future[Set[A]] = { ... }
      def remove(id: String, entry: A): Future[Set[A]] = { ... }
    }

Code
----

The current implementation is located [here](https://github.com/RBMHTechnology/eventuate/tree/master/src/main/scala/com/rbmhtechnology/eventuate/crdt). A running OR-Set example, based on a multi-JVM test, can be found [here](https://github.com/RBMHTechnology/eventuate/blob/master/src/multi-jvm/scala/com/rbmhtechnology/eventuate/crdt/ReplicatedORSetSpec.scala).
